package org.vadere.simulator.projects.dataprocessing.processors;

import java.util.Arrays;
import java.util.HashSet;
import java.util.ListIterator;
import java.util.Map.Entry;

import org.vadere.simulator.control.SimulationState;
import org.vadere.state.attributes.processors.AttributesOverlapProcessor;
import org.vadere.util.data.Row;
import org.vadere.util.data.Table;
import org.vadere.util.geometry.shapes.VPoint;

import java.util.Set;

import com.google.gson.annotations.Expose;

/**
 * Adds to the table generated by {@link PedestrianPositionProcessor} the overlap of pedestrians.
 * At this point, "overlap" is defined as "distance to another pedestrian".
 * If it is smaller than double the radius between ped i and j, the overlap counter is increased by
 * one for both i and j.
 * 
 * <p>
 * <b>Added column names</b>: overlaps {@link Integer}
 * </p>
 * 
 *
 */
public class PedestrianOverlapProcessor extends AbstractProcessor implements ForEachPedestrianPositionProcessor {

	@Expose
	private int lastStep = 1;

	@Expose
	private Table table;

	@Expose
	private Set<String> allSupportedColumns;

	private AttributesOverlapProcessor attributes;

	private PedestrianPositionProcessor pedestrianPositionProcessor;

	public PedestrianOverlapProcessor() {
		this(new AttributesOverlapProcessor(), new PedestrianPositionProcessor());
	}

	public PedestrianOverlapProcessor(
			final AttributesOverlapProcessor attributes,
			final PedestrianPositionProcessor pedestrianPositionProcessor) {
		super(new Table("overlaps"));
		this.attributes = attributes;
		this.pedestrianPositionProcessor = pedestrianPositionProcessor;
		this.pedestrianPositionProcessor.addColumnNames(pedestrianPositionProcessor.getAllColumnNames());
		table = getTable();
		allSupportedColumns = new HashSet<>();
		allSupportedColumns.addAll(Arrays.asList(table.getColumnNames()));
		allSupportedColumns.addAll(Arrays.asList(pedestrianPositionProcessor.getAllColumnNames()));
	}

	@Override
	public String[] getAllColumnNames() {
		return allSupportedColumns.toArray(new String[] {});
	}

	@Override
	public Row postUpdate(final SimulationState state, final int pedId, final VPoint position) {
		Row row = pedestrianPositionProcessor.postUpdate(state, pedId, position);
		int overlapCounter = 0;

		for (Entry<Integer, VPoint> otherPosition : state.getPedestrainPositionMap().entrySet()) {
			if (otherPosition.getKey() != pedId) {
				if (otherPosition.getValue().distance(position) < this.attributes.getPedRadius() * 2) {
					overlapCounter++;
				}
			}
		}
		row.setEntry("overlaps", overlapCounter);

		return row;
	}

	@Override
	public Table postUpdate(final SimulationState state) {
		// 1. calculate positions
		Table pedPosTable = pedestrianPositionProcessor.postUpdate(state);

		// 2. check the need of calculation and calculate additional values if necessary
		if (calculateOverlaps() && (table.isEmpty() || state.getStep() != lastStep)) {
			table.clear();

			ListIterator<Row> rowIterator = pedPosTable.listMapIterator();

			while (rowIterator.hasNext()) {
				Row row = rowIterator.next();
				Integer pedId = (Integer) row.getEntry("id");
				VPoint pedPosition = state.getPedestrianPosition(pedId);

				table.addRow();
				Row myRow = postUpdate(state, pedId, pedPosition);
				table.addColumnEntry("overlaps", myRow.getEntry("overlaps"));
			}
			table.merge(pedPosTable);
		}

		lastStep = state.getStep();
		return table;
	}

	private boolean calculateOverlaps() {
		return isColumnVisible("overlaps");
	}

	@Override
	public PedestrianOverlapProcessor clone() {
		return new PedestrianOverlapProcessor(attributes, pedestrianPositionProcessor.clone());
	}

	@Override
	public boolean equals(final Object obj) {
		if (super.equals(obj)) {
			PedestrianOverlapProcessor tmp = (PedestrianOverlapProcessor) obj;
			return tmp.attributes.equals(attributes)
					&& tmp.pedestrianPositionProcessor.equals(pedestrianPositionProcessor);
		}
		return false;
	}

	@Override
	public int hashCode() {
		int result = super.hashCode();
		result = 31 * result + attributes.hashCode();
		result = 47 * result + pedestrianPositionProcessor.hashCode();
		return result;
	}
}
