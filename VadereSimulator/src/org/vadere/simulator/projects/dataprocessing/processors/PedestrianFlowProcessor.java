package org.vadere.simulator.projects.dataprocessing.processors;

import java.util.Arrays;
import java.util.HashSet;
import java.util.ListIterator;
import java.util.Set;

import org.vadere.simulator.control.SimulationState;
import org.vadere.util.data.Row;
import org.vadere.util.data.Table;
import org.vadere.util.geometry.shapes.VPoint;

import com.google.gson.annotations.Expose;

/**
 * Adds to the table generated by {@link PedestrianDensityProcessor} the values generated by
 * {@link PedestrianVelocityProcessor} and the flow = density*velocity.
 * 
 * <p>
 * <b>Added column names</b>: density*velocity {@link Double}
 * </p>
 * 
 *
 */
public class PedestrianFlowProcessor extends AbstractProcessor implements ForEachPedestrianPositionProcessor {

	private PedestrianDensityProcessor pedestrianDensityProcessor;
	private PedestrianVelocityProcessor pedestrianVelocityProcessor;

	@Expose
	private Set<String> allSupportedColumns;

	@Expose
	private int lastStep;

	@Expose
	private Table table;

	public PedestrianFlowProcessor(final PedestrianDensityProcessor pedestrianDensityProcessor,
			final PedestrianVelocityProcessor pedestrianVelocityProcessor) {
		super(new Table("density*speed"));
		this.pedestrianDensityProcessor = pedestrianDensityProcessor;
		this.pedestrianVelocityProcessor = pedestrianVelocityProcessor;
		this.lastStep = 0;
		table = getTable();
		this.pedestrianDensityProcessor.addColumnNames(pedestrianDensityProcessor.getAllColumnNames());
		this.pedestrianVelocityProcessor.addColumnNames(pedestrianVelocityProcessor.getAllColumnNames());
		allSupportedColumns = new HashSet<>();
		allSupportedColumns.addAll(Arrays.asList(pedestrianDensityProcessor.getAllColumnNames()));
		allSupportedColumns.addAll(Arrays.asList(pedestrianVelocityProcessor.getAllColumnNames()));
		allSupportedColumns.addAll(Arrays.asList(getTable().getColumnNames()));
	}

	@Override
	public String[] getAllColumnNames() {
		return allSupportedColumns.toArray(new String[] {});
	}

	@Override
	public Table postUpdate(final SimulationState state) {
		// 1. calculate densities
		Table pedDensityTable = pedestrianDensityProcessor.postUpdate(state);

		// 2. calculate velocities
		Table pedVelocityTable = pedestrianVelocityProcessor.postUpdate(state);

		// 3. calculate flow
		if (table.isEmpty() || lastStep != state.getStep()) {
			table.clear();
			ListIterator<Row> rowIteratorDensity = pedDensityTable.listMapIterator();
			ListIterator<Row> rowIteratorVelocity = pedVelocityTable.listMapIterator();

			while (rowIteratorDensity.hasNext() && rowIteratorVelocity.hasNext()) {
				Row densityRow = rowIteratorDensity.next();
				Row velocityRow = rowIteratorVelocity.next();
				double density = (Double) densityRow.getEntry(pedestrianDensityProcessor.getDensityType());
				double velocity = (Double) velocityRow.getEntry("speed");

				table.addRow();
				table.addColumnEntry("density*speed", density * velocity);
			}

			// 4. merge all informations together
			table.merge(pedDensityTable);
			table.merge(pedVelocityTable);
		}
		lastStep = state.getStep();

		return table;

	}

	@Override
	public Row postUpdate(final SimulationState state, final int pedId, final VPoint position) {
		Row densityRow = pedestrianDensityProcessor.postUpdate(state, pedId, position);
		Row velocityRow = pedestrianVelocityProcessor.postUpdate(state, pedId, position);
		densityRow.merge(velocityRow);
		double flow = (Double) densityRow.getEntry(pedestrianDensityProcessor.getDensityType())
				* (Double) velocityRow.getEntry("speed");
		Row flowRow = new Row();
		flowRow.setEntry("density*speed", flow);
		flowRow.merge(densityRow);
		return flowRow;
	}

	@Override
	public PedestrianFlowProcessor clone() {
		return new PedestrianFlowProcessor(pedestrianDensityProcessor.clone(), pedestrianVelocityProcessor.clone());
	}
}
