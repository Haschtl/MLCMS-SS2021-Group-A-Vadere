package org.vadere.simulator.projects.dataprocessing.processors;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.vadere.simulator.control.SimulationState;
import org.vadere.state.attributes.processors.AttributesVelocityProcessor;
import org.vadere.state.scenario.Car;
import org.vadere.state.scenario.Pedestrian;
import org.vadere.util.data.Row;
import org.vadere.util.data.Table;
import org.vadere.util.geometry.shapes.VPoint;

import com.google.gson.annotations.Expose;

/**
 * Adds to the table generated by {@link PedestrianPositionProcessor} the velocity of pedestrians.
 * If the Processor reject a velocity (e.g. the velocity is to high) the row will be filled with
 * NaN values {@link Table}.
 * dx and dy are the distances covered in the last time step, vx and vy are the velocities: (dx/dt),
 * (dy/dt).
 * 
 * <p>
 * <b>Added column names</b>: dx {@link Double}, dy {@link Double}, vx {@link Double}, vy
 * {@link Double}, speed {@link Double}
 * </p>
 * 
 *
 */
public class PedestrianVelocityProcessor extends AbstractProcessor implements ForEachPedestrianPositionProcessor {
	@Expose
	private static Logger logger = LogManager.getLogger(PedestrianVelocityProcessor.class);

	@Expose
	private LinkedList<Map<Integer, VPoint>> pastPositions;

	@Expose
	private LinkedList<Double> simTimes;

	@Expose
	private Map<Integer, VPoint> currentPositions;

	@Expose
	private double currentSimTime;

	@Expose
	private int lastStep = 1;

	@Expose
	private final Table table;

	@Expose
	private Set<String> allSupportedColumns;

	private AttributesVelocityProcessor attributes;

	private PedestrianPositionProcessor pedestrianPositionProcessor;

	public PedestrianVelocityProcessor() {
		this(new AttributesVelocityProcessor(), new PedestrianPositionProcessor());
	}

	public PedestrianVelocityProcessor(
			final AttributesVelocityProcessor attributes,
			final PedestrianPositionProcessor pedestrianPositionProcessor) {
		super(new Table("dx", "dy", "vx", "vy", "speed"));
		this.attributes = attributes;
		this.pedestrianPositionProcessor = pedestrianPositionProcessor;
		this.pedestrianPositionProcessor.addColumnNames(pedestrianPositionProcessor.getAllColumnNames());
		this.pastPositions = new LinkedList<>();
		this.simTimes = new LinkedList<>();
		this.currentPositions = new HashMap<>();
		table = getTable();
		allSupportedColumns = new HashSet<>();
		allSupportedColumns.addAll(Arrays.asList(table.getColumnNames()));
		allSupportedColumns.addAll(Arrays.asList(pedestrianPositionProcessor.getAllColumnNames()));
	}

	@Override
	public String[] getAllColumnNames() {
		return allSupportedColumns.toArray(new String[] {});
	}

	@Override
	public Table preLoop(SimulationState state) {
		currentSimTime = state.getSimTimeInSec();
		return super.preLoop(state);
	}

	@Override
	public Row postUpdate(final SimulationState state, final int pedId, final VPoint position) {
		Row row = pedestrianPositionProcessor.postUpdate(state, pedId, position);

		if (lastStep != state.getStep()) {
			pastPositions.addFirst(currentPositions);
			lastStep = state.getStep();
			currentPositions = new HashMap<>();
			simTimes.addFirst(currentSimTime);
			if (pastPositions.size() > attributes.getBackSteps()) {
				pastPositions.removeLast();
				simTimes.removeLast();
			}
			currentSimTime = state.getSimTimeInSec();
		}

		currentPositions.put(pedId, position);
		VPoint lastPedPosition;

		if (pastPositions.size() < attributes.getBackSteps()) {
			lastPedPosition = null;
		} else {
			lastPedPosition = pastPositions.getLast().get(pedId);
		}

		double[] velocityVector;
		double dt = 0;
		if (lastPedPosition != null) {
			velocityVector = getVelocity(lastPedPosition, position, simTimes.getLast(), state.getSimTimeInSec());
			dt = state.getSimTimeInSec() - simTimes.getLast();
		} else {
			if (simTimes.size() > 0)
				dt = state.getSimTimeInSec() - simTimes.getLast();

			Pedestrian p = state.getTopography().getElement(Pedestrian.class, pedId);
			Car c = state.getTopography().getElement(Car.class, pedId);
			if (p == null && c == null) {
				logger.error("Object is neither a Pedestrian or Car.");
				return row;
			}
			VPoint vel = new VPoint(0, 0);
			if (c != null) {
				vel = c.getVelocity();
			} else if (p != null) {
				vel = p.getVelocity();
			}


			vel = vel.scalarMultiply(dt);

			if (attributes.isOnlyXDirection()) {
				velocityVector = new double[] {vel.x, vel.y, Math.abs(vel.x)};
			} else {
				velocityVector = new double[] {vel.x, vel.y, vel.distance(VPoint.ZERO)};
			}
		}

		if (velocityVector[2] <= attributes.getMaxAcceptedVelocity() && !Double.isNaN(velocityVector[2])) {
			row.setEntry("dx", velocityVector[0]);
			row.setEntry("dy", velocityVector[1]);
			row.setEntry("vx", dt > 0 ? velocityVector[0] / dt : 0.0);
			row.setEntry("vy", dt > 0 ? velocityVector[1] / dt : 0.0);
			row.setEntry("speed", velocityVector[2]);
		} else {
			row.setEntry("dx", Double.NaN);
			row.setEntry("dy", Double.NaN);
			row.setEntry("vx", Double.NaN);
			row.setEntry("vy", Double.NaN);
			row.setEntry("speed", Double.NaN);

			logger.error(String.format("rejected speed: %f", velocityVector[2]));
		}

		return row;
	}

	@Override
	public Table postUpdate(final SimulationState state) {
		// 1. calculate positions
		Table pedPosTable = pedestrianPositionProcessor.postUpdate(state);

		// 2. check the need of calculation and calculate additional values if necessary
		if (calculateVelocity() && (table.isEmpty() || state.getStep() != lastStep)) {
			table.clear();

			ListIterator<Row> rowIterator = pedPosTable.listMapIterator();

			while (rowIterator.hasNext()) {
				Row row = rowIterator.next();
				Integer pedId = (Integer) row.getEntry("id");
				VPoint pedPosition = state.getPedestrianPosition(pedId);

				table.addRow();
				Row myRow = postUpdate(state, pedId, pedPosition);
				table.addColumnEntry("dx", myRow.getEntry("dx"));
				table.addColumnEntry("dy", myRow.getEntry("dy"));
				table.addColumnEntry("vx", myRow.getEntry("vx"));
				table.addColumnEntry("vy", myRow.getEntry("vy"));
				table.addColumnEntry("speed", myRow.getEntry("speed"));
			}
			table.merge(pedPosTable);
		}

		lastStep = state.getStep();
		return table;
	}

	private boolean calculateVelocity() {
		return isColumnVisible("speed") || isColumnVisible("dx") || isColumnVisible("dy") || isColumnVisible("vx")
				|| isColumnVisible("vy");
	}

	private double[] getVelocity(final VPoint p0, final VPoint p1, final double t0, final double t1) {
		double[] resultVector = new double[3];
		double dx = (p1.getX() - p0.getX());
		double dy = (p1.getY() - p0.getY());
		double dt = (t1 - t0);
		double velocity = Math.hypot(dx, dy) / dt;

		if (attributes.isOnlyXDirection()) {
			velocity = Math.abs(dx) / dt;
		} else {
			velocity = Math.hypot(dx, dy) / dt;
		}

		resultVector[0] = dx;
		resultVector[1] = dy;
		resultVector[2] = velocity;

		return resultVector;
	}

	@Override
	public PedestrianVelocityProcessor clone() {
		return new PedestrianVelocityProcessor(attributes, pedestrianPositionProcessor.clone());
	}


	@Override
	public boolean equals(final Object obj) {
		if (super.equals(obj)) {
			PedestrianVelocityProcessor tmp = (PedestrianVelocityProcessor) obj;
			return tmp.attributes.equals(attributes)
					&& tmp.pedestrianPositionProcessor.equals(pedestrianPositionProcessor);
		}
		return false;
	}

	@Override
	public int hashCode() {
		int result = super.hashCode();
		result = 31 * result + attributes.hashCode();
		result = 47 * result + pedestrianPositionProcessor.hashCode();
		return result;
	}
}
