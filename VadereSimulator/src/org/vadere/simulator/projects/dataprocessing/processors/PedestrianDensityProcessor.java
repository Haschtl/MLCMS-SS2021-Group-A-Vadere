package org.vadere.simulator.projects.dataprocessing.processors;


import com.google.gson.annotations.Expose;

import java.util.Arrays;
import java.util.HashSet;
import java.util.ListIterator;
import java.util.Set;

import org.vadere.simulator.control.SimulationState;
import org.vadere.util.data.Row;
import org.vadere.util.data.Table;
import org.vadere.util.geometry.shapes.VPoint;

/**
 * Adds the density of the position of each pedestrian to the table generated by
 * {@link PedestrianPositionProcessor}.
 * The Density is calculate by a {@link DensityProcessor}.
 * 
 * <p>
 * <b>Added column names</b>: density {@link Double} (the real name of the column is specified by
 * the subclass!)
 * </p>
 *
 *
 */
public class PedestrianDensityProcessor extends AbstractProcessor implements ForEachPedestrianPositionProcessor {

	private DensityProcessor densityProcessor;

	@Expose
	private PedestrianPositionProcessor pedestrianPositionProcessor;

	@Expose
	private final Table table;

	@Expose
	private int lastStep;

	@Expose
	private Set<String> allSupportedColumns;

	public PedestrianDensityProcessor() {
		this(new PedestrianPositionProcessor(), new DensityCountingProcessor());
	}

	public PedestrianDensityProcessor(
			final PedestrianPositionProcessor pedestrianPositionProcessor,
			final DensityProcessor densityProcessor) {
		super(new Table(densityProcessor.getDensityType()));
		this.densityProcessor = densityProcessor;
		this.densityProcessor.addColumnNames(densityProcessor.getAllColumnNames());

		this.pedestrianPositionProcessor = pedestrianPositionProcessor;
		this.pedestrianPositionProcessor.addColumnNames(pedestrianPositionProcessor.getAllColumnNames());

		this.lastStep = 0;
		table = getTable();

		allSupportedColumns = new HashSet<>();
		allSupportedColumns.addAll(Arrays.asList(densityProcessor.getAllColumnNames()));
		allSupportedColumns.addAll(Arrays.asList(pedestrianPositionProcessor.getAllColumnNames()));
	}

	@Override
	public Row postUpdate(final SimulationState state, final int pedId, final VPoint position) {
		Row row = pedestrianPositionProcessor.postUpdate(state, pedId, position);
		row.setEntry(densityProcessor.getDensityType(), getPedestrianDensity(state, pedId, position));
		return row;
	}

	@Override
	public Table preLoop(SimulationState state) {
		pedestrianPositionProcessor.preLoop(state);
		densityProcessor.preLoop(state);
		return super.preLoop(state);
	}

	@Override
	public String[] getAllColumnNames() {
		return allSupportedColumns.toArray(new String[] {});
	}

	@Override
	public Table postUpdate(final SimulationState state) {

		// 1. calculate Positions
		Table pedPositionTable = pedestrianPositionProcessor.postUpdate(state);

		// 2. calculate densities
		if (table.isEmpty() || lastStep != state.getStep()) {
			table.clear();
			ListIterator<Row> rowIterator = pedPositionTable.listMapIterator();
			while (rowIterator.hasNext()) {
				Row row = rowIterator.next();
				int id = (Integer) row.getEntry("id");

				double density = getPedestrianDensity(state, id, state.getPedestrianPosition(id));
				table.addRow();
				table.addColumnEntry(densityProcessor.getDensityType(), density);
			}

			// 3. merge all informations together
			table.merge(pedPositionTable);
		}
		lastStep = state.getStep();

		return table;

	}

	/**
	 * Returns a unique table column name for the specific density type (gausian, jts, counting ...)
	 * 
	 * @return a unique table column name for the specific density
	 */
	protected String getDensityType() {
		return densityProcessor.getDensityType();
	}

	private double getPedestrianDensity(final SimulationState state, final int pedId, final VPoint position) {
		// copy to avoid modification concurrent exceptions!
		// Map<Integer, VPoint> copy = new HashMap<>(state.getPedestrainPositionMap());
		// copy.remove(pedId);
		VPoint filteredPosition = new VPoint(Math.max(0, Math.min(state.getTopography().getBounds().width, position.x)),
				Math.max(0, Math.min(state.getTopography().getBounds().height, position.y)));
		return densityProcessor.getDensity(filteredPosition, state);
	}

	@Override
	public PedestrianDensityProcessor clone() {
		return new PedestrianDensityProcessor(pedestrianPositionProcessor.clone(), densityProcessor.clone());
	}

	@Override
	public boolean equals(final Object obj) {
		if (super.equals(obj)) {
			PedestrianDensityProcessor tmp = (PedestrianDensityProcessor) obj;
			return tmp.densityProcessor.equals(densityProcessor) &&
					tmp.pedestrianPositionProcessor.equals(pedestrianPositionProcessor);
		}
		return false;
	}

	@Override
	public int hashCode() {
		int result = super.hashCode();
		result = 31 * result + densityProcessor.hashCode();
		result = 31 * result + pedestrianPositionProcessor.hashCode();
		return result;
	}
}
